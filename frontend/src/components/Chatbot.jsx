import { useState, useRef, useEffect } from "react";
import ChatHeader from "./ChatHeader";
import ChatFooter from "./ChatFooter";
import Message from "./Message";

const API_KEY = "AIzaSyA6YFHqj8ukTcTXRkk8OdNwQaloxJm4cZI";
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`; // S·ª≠ d·ª•ng model gemini-1.5-flash

export default function Chatbot() {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState([
    { role: "bot", content: "Xin ch√†o üëã T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay?" },
  ]);
  //M·∫£ng l∆∞u l·ªãch s·ª≠ chat
  //role: "user" ho·∫∑c "model".
  //parts: M·∫£ng ch·ª©a c√°c ph·∫ßn n·ªôi dung
  const [chatHistory, setChatHistory] = useState([]);

  //Tham chi·∫øu ƒë·∫øn khu v·ª±c hi·ªÉn th·ªã tin nh·∫Øn ƒë·ªÉ cu·ªôn t·ª± ƒë·ªông.
  const chatBodyRef = useRef(null);

  const scrollToBottom = () => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight;
    }
  };

  //Khi messages thay ƒë·ªïi, g·ªçi scrollToBottom() ƒë·ªÉ cu·ªôn xu·ªëng tin nh·∫Øn m·ªõi nh·∫•t.
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  //  Danh s√°ch k·ªãch b·∫£n ƒë·∫∑t l·ªãch kh√°m
  const scriptedResponses = [
    {
      keywords: ["ƒë·∫∑t l·ªãch", "kh√°m b·ªánh", "l·ªãch kh√°m"],
      response:
        "B·∫°n mu·ªën ƒë·∫∑t l·ªãch kh√°m? Vui l√≤ng cho t√¥i bi·∫øt: h·ªç t√™n, s·ªë ƒëi·ªán tho·∫°i, chuy√™n khoa v√† th·ªùi gian mong mu·ªën.",
    },
    {
      keywords: ["b√°c sƒ©", "chuy√™n khoa"],
      response:
        "Hi·ªán ph√≤ng kh√°m c√≥ c√°c chuy√™n khoa: N·ªôi t·ªïng qu√°t, Tai M≈©i H·ªçng, Nhi khoa, Da li·ªÖu. B·∫°n c·∫ßn kh√°m chuy√™n khoa n√†o?",
    },
    {
      keywords: ["th·ªùi gian", "gi·ªù l√†m vi·ªác", "m·ªü c·ª≠a"],
      response:
        "Ph√≤ng kh√°m ho·∫°t ƒë·ªông t·ª´ 7:30 s√°ng ƒë·∫øn 5:30 chi·ªÅu, Th·ª© 2 ƒë·∫øn Th·ª© 7.",
    },
    {
      keywords: ["h·ªßy l·ªãch", "h·ªßy kh√°m"],
      response:
        "B·∫°n mu·ªën h·ªßy l·ªãch? Vui l√≤ng cung c·∫•p m√£ l·ªãch h·∫πn ho·∫∑c th√¥ng tin ƒë·∫∑t l·ªãch tr∆∞·ªõc ƒë√≥.",
    },
    {
      keywords: ["c·∫£m ∆°n", "thanks"],
      response: "R·∫•t h√¢n h·∫°nh ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n! N·∫øu c·∫ßn th√™m g√¨, c·ª© nh·∫Øn nh√©.",
    },
  ];
  // Ph∆∞∆°ng th·ª©c find duy·ªát qua m·∫£ng scriptedResponses, tr·∫£ v·ªÅ object ƒë·∫ßu ti√™n th·ªèa m√£n ƒëi·ªÅu ki·ªán ho·∫∑c undefined n·∫øu kh√¥ng t√¨m th·∫•y.
  // ƒêi·ªÅu ki·ªán: item.keywords.some((keyword) => lowered.includes(keyword)).
  // item.keywords: M·∫£ng t·ª´ kh√≥a c·ªßa m·ªôt k·ªãch b·∫£n (VD: ["ƒë·∫∑t l·ªãch", "kh√°m b·ªánh", "l·ªãch kh√°m"]).
  // some: Ki·ªÉm tra xem c√≥ √≠t nh·∫•t m·ªôt keyword n·∫±m trong lowered kh√¥ng.
  // lowered.includes(keyword): Ki·ªÉm tra xem chu·ªói lowered c√≥ ch·ª©a keyword kh√¥ng.
  // V√≠ d·ª•: N·∫øu lowered = "t√¥i mu·ªën ƒë·∫∑t l·ªãch kh√°m", keyword = "ƒë·∫∑t l·ªãch", th√¨ includes("ƒë·∫∑t l·ªãch") tr·∫£ v·ªÅ true.
  const checkScriptedResponse = (text) => {
    const lowered = text.toLowerCase();
    return (
      scriptedResponses.find((item) =>
        item.keywords.some((keyword) => lowered.includes(keyword))
      )?.response || null
    );
  };
  //x·ª≠ l√Ω tin nh·∫Øn ng∆∞·ªùi d√πng, th√™m tin nh·∫Øn v√†o danh s√°ch hi·ªÉn th·ªã
  //v√† ki·ªÉm tra xem tin nh·∫Øn c√≥ ch·ª©a chuy√™n khoa n√†o kh√¥ng ƒë·ªÉ h·ªó tr·ª£ ƒë·∫∑t l·ªãch kh√°m
  const sendMessage = async (text) => {
    if (!text.trim()) return; // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng ƒë·∫ßu/cu·ªëi c·ªßa text

    const newUserMessage = { role: "user", content: text };
    setMessages((prev) => [...prev, newUserMessage]); //gi·ªØ l·∫°i c√°c tin nh·∫Øn c≈©, th√™m newUserMessage v√†o cu·ªëi.

    //Ph√°t hi·ªán chuy√™n khoa:
    const specialities = [
      "n·ªôi t·ªïng qu√°t",
      "tai m≈©i h·ªçng",
      "nhi khoa",
      "da li·ªÖu",
    ];
    const loweredText = text.toLowerCase();
    //find ƒë·ªÉ t√¨m chuy√™n khoa ƒë·∫ßu ti√™n c√≥ trong loweredText
    const detectedSpeciality = specialities.find(
      (sp) => loweredText.includes(sp) //ki·ªÉm tra xem chu·ªói loweredText c√≥ ch·ª©a chuy√™n khoa sp
    );
    //N·∫øu t√¨m th·∫•y, detectedSpeciality l√† chu·ªói (VD: "n·ªôi t·ªïng qu√°t").
    //N·∫øu kh√¥ng, detectedSpeciality l√† undefined.

    //Tr√≠ch xu·∫•t ng√†y v√† gi·ªù t·ª´ tin nh·∫Øn ng∆∞·ªùi d√πng ƒë·ªÉ s·ª≠ d·ª•ng trong vi·ªác g·ªçi API ki·ªÉm tra b√°c sƒ© tr·ªëng.
    let time = null; //L∆∞u gi·ªù ƒë∆∞·ª£c tr√≠ch xu·∫•t
    let date = null; //L∆∞u ng√†y ƒë∆∞·ª£c tr√≠ch xu·∫•t

    //T√¨m ng√†y trong tin nh·∫Øn v·ªõi c√°c ƒë·ªãnh d·∫°ng dd/mm/yyyy, dd-mm-yyyy, ho·∫∑c yyyy-mm-dd, sau ƒë√≥ ƒë·ªãnh d·∫°ng th√†nh YYYY-MM-DD.
    //     Regex gi·∫£i th√≠ch:
    // (\d{1,2}): Nh√≥m 1, kh·ªõp 1 ho·∫∑c 2 ch·ªØ s·ªë (ng√†y ho·∫∑c nƒÉm, v√≠ d·ª•: 15 ho·∫∑c 05).
    // [\/\-]: Kh·ªõp k√Ω t·ª± / ho·∫∑c - (ph√¢n c√°ch).
    // (\d{1,2}): Nh√≥m 2, kh·ªõp 1 ho·∫∑c 2 ch·ªØ s·ªë (th√°ng).
    // [\/\-]: Ph√¢n c√°ch ti·∫øp theo.
    // (\d{4}): Nh√≥m 3, kh·ªõp ƒë√∫ng 4 ch·ªØ s·ªë (nƒÉm).
    // V√≠ d·ª•: V·ªõi 15/05/2025, regex kh·ªõp:
    // Nh√≥m 1: 15 (ng√†y).
    // Nh√≥m 2: 05 (th√°ng).
    // Nh√≥m 3: 2025 (nƒÉm).
    const dateRegex = /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/;
    const dateMatch = text.match(dateRegex); //t√¨m chu·ªói trong text kh·ªõp v·ªõi dateRegex (v√≠ d·ª• ng∆∞·ªùi d√πng nh·∫≠p ng√†y ƒë·ªÉ t√¨m b√°c sƒ©)
    //// dateMatch = ["15_5_2025", "15", "5", "2025"]
    //   destructuring m·∫£ng dateMatch v√¨ thay v√¨ truy c·∫≠p c√°c ph·∫ßn t·ª≠ c·ªßa dateMatch b·∫±ng ch·ªâ s·ªë:
    // _: B·ªè qua ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n (dateMatch[0]).
    // d: Ng√†y (dateMatch[1]).
    // m: Th√°ng (dateMatch[2]).
    // y: NƒÉm (dateMatch[3]).

    //B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng destructuring ƒë·ªÉ g√°n tr·ª±c ti·∫øp c√°c ph·∫ßn t·ª≠ v√†o bi·∫øn
    if (dateMatch) {
      const [_, d, m, y] = dateMatch;
      //  T·∫°o chu·ªói date ƒë·ªãnh d·∫°ng YYYY-MM-DD.
      // m.padStart(2, "0"): ƒê·∫£m b·∫£o th√°ng c√≥ 2 ch·ªØ s·ªë (v√≠ d·ª•: "5" ‚Üí "05").
      // d.padStart(2, "0"): ƒê·∫£m b·∫£o ng√†y c√≥ 2 ch·ªØ s·ªë.
      date = `${y}-${m.padStart(2, "0")}-${d.padStart(2, "0")}`;
    } else {
      // M·∫∑c ƒë·ªãnh h√¥m nay n·∫øu kh√¥ng c√≥ ng√†y
      date = new Date().toISOString().split("T")[0];
    }

    // T√°ch gi·ªù
    // V√≠ d·ª•: V·ªõi text = "Kh√°m ng√†y 15/05/2025 l√∫c 9h", n·∫øu kh√¥ng x√≥a 15/05/2025, timeRegex c√≥ th·ªÉ kh·ªõp 15 (ng√†y) thay v√¨ 9 (gi·ªù).
    const textWithoutDate = text.replace(dateRegex, "");

    //?: To√†n b·ªô ph·∫ßn ph√∫t n√†y kh√¥ng b·∫Øt bu·ªôc
    //\s*: T√¨m kho·∫£ng tr·∫Øng (
    // \i: Kh√¥ng quan t√¢m hoa/th∆∞·ªùng
    //(\d{1,2}): T√¨m 1 ƒë·∫øn 2 s·ªë cho ng√†y
    //(\d{0,2}): T√¨m 0 ƒë·∫øn 2 s·ªë cho ph√∫t
    //gom m·ªôt s·ªë ph·∫ßn l·∫°i ƒë·ªÉ d·ªÖ t√¨m, nh∆∞ng kh√¥ng l∆∞u ph·∫ßn ƒë√≥ v√†o danh s√°ch k·∫øt qu·∫£. ƒê√¢y l√† non-capturing group ((?:...)),
    const timeRegex =
      /(\d{1,2})(?:[:h gi·ªù]?(\d{0,2}))?(?:\s*(s√°ng|chi·ªÅu|t·ªëi|am|pm))?/i;
    const timeMatch = textWithoutDate.match(timeRegex);
    //ph∆∞∆°ng th·ª©c match ƒë·ªÉ t√¨m chu·ªói trong textWithoutDate kh·ªõp v·ªõi timeRegex. K·∫øt qu·∫£ ƒë∆∞·ª£c l∆∞u v√†o timeMatch.
    // _: B·ªè qua ph·∫ßn t·ª≠ 0 (chu·ªói kh·ªõp ho√†n ch·ªânh, VD: "9h30 s√°ng"), v√¨ kh√¥ng c·∫ßn d√πng.
    // h: L·∫•y ph·∫ßn t·ª≠ 1 (gi·ªù, VD: "9").
    // m: L·∫•y ph·∫ßn t·ª≠ 2 (ph√∫t, VD: "30" ho·∫∑c "").
    // period: L·∫•y ph·∫ßn t·ª≠ 3 (kho·∫£ng th·ªùi gian, VD: "s√°ng" ho·∫∑c undefined).
    if (timeMatch) {
      let [_, h, m, period] = timeMatch;
      h = parseInt(h);
      m = m ? parseInt(m) : 0;

      if (period) {
        period = period.toLowerCase();
        //// v√≠ d·ª• 3 gi·ªù chi·ªÅu => b√© h∆°n 12h th√¨ c·ªông th√™m 12 cho gi·ªù ƒë√£ ·ªü ƒë·ªãnh d·∫°ng 24 gi·ªù
        //h = 3, period = "pm" ‚Üí h = 3 + 12 = 15.
        if (["chi·ªÅu", "t·ªëi", "pm"].includes(period) && h < 12) h += 12;
        if (["s√°ng", "am"].includes(period) && h === 12) h = 0;
      }
      //ƒêo·∫°n code n√†y l√† b∆∞·ªõc trung gian trong vi·ªác tr√≠ch xu·∫•t gi·ªù t·ª´ tin nh·∫Øn ƒë·ªÉ t·∫°o chu·ªói time (VD: "09:30")
      //D√πng h v√† m ƒë·ªÉ t·∫°o chu·ªói HH:MM (VD: h = 9, m = 30 ‚Üí time = "09:30").
      const hourStr = h.toString().padStart(2, "0");
      const minStr = m.toString().padStart(2, "0");
      time = `${hourStr}:${minStr}`;
    }

    if (time || detectedSpeciality) {
      const loadingMessage = {
        role: "bot",
        content: "ƒêang ki·ªÉm tra b√°c sƒ© c√≤n tr·ªëng...",
      };
      //L·∫•y danh s√°ch tin nh·∫Øn hi·ªán t·∫°i (prev).
      //Th√™m loadingMessage v√†o cu·ªëi danh s√°ch b·∫±ng to√°n t·ª≠ spread ([...prev, loadingMessage]).
      setMessages((prev) => [...prev, loadingMessage]);
      //T·∫°o URL cho y√™u c·∫ßu GET t·ªõi API backend, bao g·ªìm c√°c tham s·ªë time, speciality, v√† date.
      try {
        let url = `http://localhost:4000/api/doctor/available?time=${
          time || "09:00"
        }`;
        //N·∫øu detectedSpeciality t·ªìn t·∫°i
        //, th√™m query parameter speciality.
        //encodeURIComponent(detectedSpeciality): M√£ h√≥a gi√° tr·ªã ƒë·ªÉ x·ª≠ l√Ω k√Ω t·ª± ƒë·∫∑c bi·ªát   khi g·ª≠i d·ªØ li·ªáu qua URL
        //ƒê·∫£m b·∫£o t√≠nh to√†n v·∫πn d·ªØ li·ªáu: Khi g·ª≠i d·ªØ li·ªáu qua HTTP (GET/POST), c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát c√≥ th·ªÉ l√†m h·ªèng c·∫•u tr√∫c c·ªßa URL
        if (detectedSpeciality) {
          url += `&speciality=${encodeURIComponent(detectedSpeciality)}`;
        }
        //N·∫øu date t·ªìn t·∫°i (VD: "2025-05-15"), th√™m query parameter date
        if (date) {
          url += `&date=${date}`;
        }
        //G·ª≠i y√™u c·∫ßu GET t·ªõi URL API v√† chuy·ªÉn ph·∫£n h·ªìi th√†nh d·ªØ li·ªáu JSON.
        const res = await fetch(url);
        const data = await res.json();
        //X·ª≠ l√Ω d·ªØ li·ªáu v√† t·∫°o tin nh·∫Øn ph·∫£n h·ªìi
        //Th√†nh c√¥ng, c√≥ b√°c sƒ©
        const reply = data.success
          ? data.doctors.length > 0 //T·∫°o chu·ªói th√¥ng b√°o v·ªõi danh s√°ch b√°c sƒ©
            ? `B√°c sƒ© ${
                detectedSpeciality || ""
              } c√≤n tr·ªëng l√∫c ${time} ng√†y ${date}:\n${data.doctors
                // L·∫∑p qua m·∫£ng doctors, t·∫°o danh s√°ch li√™n k·∫øt HTML cho m·ªói b√°c sƒ©
                .map(
                  (d) =>
                    `‚Ä¢ <a href="/appointment/${d.id}" class="text-blue-600 underline hover:text-blue-800" target="_blank">${d.name}</a>`
                )
                .join("<br>")}\nB·∫°n mu·ªën ƒë·∫∑t v·ªõi ai?`
            : `Kh√¥ng c√≥ b√°c sƒ© ${
                // T·∫°o tin nh·∫Øn th√¥ng b√°o kh√¥ng c√≥ b√°c sƒ©.
                detectedSpeciality ? `${detectedSpeciality} ` : ""
              }tr·ªëng l√∫c ${time} ng√†y ${date}.`
          : `Kh√¥ng th·ªÉ ki·ªÉm tra b√°c sƒ©: ${data.message}`;
        //C·∫≠p nh·∫≠t tin nh·∫Øn ph·∫£n h·ªìi
        //prev: Danh s√°ch tin nh·∫Øn hi·ªán t·∫°i.
        //prev.slice(0, -1): L·∫•y t·∫•t c·∫£ tin nh·∫Øn tr·ª´ tin nh·∫Øn cu·ªëi (tin nh·∫Øn loading).
        //reply : n·ªôi dung
        setMessages((prev) => [
          ...prev.slice(0, -1),
          { role: "bot", content: reply },
        ]);
        return;
      } catch (err) {
        console.error("L·ªói khi g·ªçi API b√°c sƒ©:", err.message);
        setMessages((prev) => [
          ...prev.slice(0, -1),
          {
            role: "bot",
            content: "C√≥ l·ªói x·∫£y ra khi ki·ªÉm tra b√°c sƒ©. Vui l√≤ng th·ª≠ l·∫°i sau!",
          },
        ]);
        return;
      }
    }

    //  Check k·ªãch b·∫£n
    //H√†m n√†y nh·∫≠n text (tin nh·∫Øn ng∆∞·ªùi d√πng) v√† chuy·ªÉn th√†nh ch·ªØ th∆∞·ªùng (lowered) ƒë·ªÉ so s√°nh kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng v√† check xem trong ƒë√≥ c√≥ keyword kh√¥ngkh√¥ng
    const scriptedReply = checkScriptedResponse(text);
    if (scriptedReply) {
      const scriptedBotMessage = { role: "bot", content: scriptedReply }; //content: scriptedReply: N·ªôi dung ph·∫£n h·ªìi theo k·ªãch b·∫£n.
      setMessages((prev) => [...prev, scriptedBotMessage]); //gi·ªØ c√°c tin nh·∫Øn c≈© v√† th√™m tin nh·∫Øn bot m·ªõi v√†o cu·ªëi.
      return;
    }

    //Hi·ªÉn th·ªã tin nh·∫Øn "ƒêang x·ª≠ l√Ω"
    const thinkingMessage = { role: "bot", content: "..." };
    setMessages((prev) => [...prev, thinkingMessage]); //th√™m tin nh·∫Øn "..." v√†o cu·ªëi m·∫£ng.
    //G·ªçi API Gemini
    try {
      const response = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" }, //ƒê·ªãnh d·∫°ng d·ªØ li·ªáu g·ª≠i ƒëi l√† JSON.
        mode: "cors", // tr√°nh l·ªói CORS khi g·ªçi API t·ª´ m·ªôt mi·ªÅn kh√°c.
        body: JSON.stringify({
          contents: [...chatHistory, { role: "user", parts: [{ text }] }],
        }),
      });

      if (!response.ok) {
        throw new Error(
          `L·ªói API Gemini: ${response.status} ${response.statusText}`
        );
      }
      //ƒë·ªÉ tr√≠ch xu·∫•t n·ªôi dung vƒÉn b·∫£n t·ª´ ph·∫£n h·ªìi JSON c·ªßa API Gemini
      //? cho ph√©p truy c·∫≠p v√†o c√°c thu·ªôc t√≠nh ho·∫∑c ph·∫ßn t·ª≠ c·ªßa m·ªôt ƒë·ªëi t∆∞·ª£ng m√† kh√¥ng g√¢y l·ªói n·∫øu m·ªôt ph·∫ßn trong chu·ªói truy c·∫≠p l√† null ho·∫∑c undefined.
      //candidates th∆∞·ªùng l√† m·ªôt m·∫£ng ch·ª©a c√°c ph·∫£n h·ªìi ti·ªÅm nƒÉng t·ª´ m√¥ h√¨nh AI
      //data?.candidates: Truy c·∫≠p v√†o m·∫£ng candidates trong data.
      //[0]: Truy c·∫≠p v√†o ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n c·ªßa m·∫£ng candidates.
      // Gi·∫£ ƒë·ªãnh: API Gemini tr·∫£ v·ªÅ m·ªôt m·∫£ng candidates, v√† ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n ([0]) ch·ª©a ph·∫£n h·ªìi ch√≠nh (ho·∫∑c ph·∫£n h·ªìi ƒë∆∞·ª£c ∆∞u ti√™n).

      //data?.candidates?.[0]?.content
      //content: Thu·ªôc t√≠nh n√†y n·∫±m trong ƒë·ªëi t∆∞·ª£ng t·∫°i candidates[0]. N√≥ ch·ª©a n·ªôi dung c·ªßa ph·∫£n h·ªìi t·ª´ m√¥ h√¨nh AI.
      //Gi·∫£ ƒë·ªãnh: candidates[0] l√† m·ªôt ƒë·ªëi t∆∞·ª£ng c√≥ thu·ªôc t√≠nh content.
      //parts th∆∞·ªùng l√† m·ªôt m·∫£ng ch·ª©a c√°c ph·∫ßn c·ªßa n·ªôi dung ph·∫£n h·ªìi (v√≠ d·ª•: c√°c ƒëo·∫°n vƒÉn b·∫£n, h√¨nh ·∫£nh, ho·∫∑c c√°c lo·∫°i d·ªØ li·ªáu kh√°c).
      //text: Thu·ªôc t√≠nh n√†y n·∫±m trong parts[0]. N√≥ ch·ª©a chu·ªói vƒÉn b·∫£n th·ª±c t·∫ø c·ªßa ph·∫£n h·ªìi t·ª´ m√¥ h√¨nh AI.

      //{ candidates: [{ content: { parts: [{ text: "N·ªôi dung ph·∫£n h·ªìi" }] } }]}
      //       Quy tr√¨nh:
      // B·∫Øt ƒë·∫ßu t·ª´ data (JSON t·ª´ API).
      // Truy c·∫≠p m·∫£ng candidates, l·∫•y ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n ([0]).
      // L·∫•y ƒë·ªëi t∆∞·ª£ng content, r·ªìi m·∫£ng parts b√™n trong.
      // L·∫•y ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n c·ªßa parts ([0]) v√† thu·ªôc t√≠nh text.
      const data = await response.json();
      const reply =
        data?.candidates?.[0]?.content?.parts?.[0]?.text ||
        "Xin l·ªói, t√¥i kh√¥ng hi·ªÉu.";

      setMessages((prev) => [
        ...prev.slice(0, -1), //L·∫•y t·∫•t c·∫£ tin nh·∫Øn tr·ª´ tin nh·∫Øn cu·ªëi c√πng
        { role: "bot", content: reply },
      ]);
      setChatHistory((prev) => [
        ...prev,
        { role: "user", parts: [{ text }] }, //Tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng
        { role: "model", parts: [{ text: reply }] }, //Ph·∫£n h·ªìi c·ªßa m√¥ h√¨nh
      ]);
    } catch (error) {
      console.error("L·ªói khi g·ªçi API Gemini:", error.message);
      setMessages((prev) => [
        ...prev.slice(0, -1),
        { role: "bot", content: `C√≥ l·ªói x·∫£y ra: ${error.message}` },
      ]);
    }
  };

  return (
    <div>
      {/* Toggle Button */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="fixed bottom-8 right-8 bg-blue-500 text-white p-3 rounded-full shadow-lg hover:bg-blue-600"
      >
        {isOpen ? "‚úñ" : "üí¨"}
      </button>

      {isOpen && (
        <div className="fixed bottom-24 right-8 w-96 bg-white rounded-2xl shadow-2xl flex flex-col overflow-hidden z-[9999]">
          <ChatHeader onClose={() => setIsOpen(false)} />
          <div
            ref={chatBodyRef}
            className="p-4 space-y-4 overflow-y-auto max-h-[500px] scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-100"
          >
            {/* messages l√† m·ªôt m·∫£ng state ch·ª©a c√°c tin nh·∫Øn (gi·∫£ ƒë·ªãnh t·ª´ ƒëo·∫°n m√£ tr∆∞·ªõc, c√≥ d·∫°ng { role: "user" | "bot", content: string }).
L·∫∑p qua t·ª´ng msg trong messages, render component Message. */}
            {messages.map((msg, idx) => (
              // Message l√† component ri√™ng ƒë·ªÉ hi·ªÉn th·ªã m·ªôt tin nh·∫Øn.
              // key={idx}: ƒê·∫£m b·∫£o React ph√¢n bi·ªát c√°c tin nh·∫Øn (d√πng ch·ªâ s·ªë idx l√†m key, nh∆∞ng l√Ω t∆∞·ªüng n√™n d√πng ID duy nh·∫•t n·∫øu c√≥).
              // message={msg}: Truy·ªÅn ƒë·ªëi t∆∞·ª£ng tin nh·∫Øn (msg) ƒë·ªÉ Message hi·ªÉn th·ªã n·ªôi dung v√† ƒë·ªãnh d·∫°ng (v√≠ d·ª•: tin nh·∫Øn ng∆∞·ªùi d√πng b√™n ph·∫£i, bot b√™n tr√°i).
              <Message key={idx} message={msg} />
            ))}
          </div>
          <ChatFooter onSend={sendMessage} />
        </div>
      )}
    </div>
  );
}
